# Superhero Choice

- 현재 적용된 기술: Create React App, TypeScript, Sass(SCSS), React Router, React Query, Axios, Recoil, Firebase, lodash, classnames, ESLint, Stylelint, Prettier
- 제거된 기술: store-js

## 1. 구현된 프로젝트 확인 방법

### Vercel로 배포된 페이지

🔗 [링크](https://superhero-choice.vercel.app/)

## 2. 폴더 구조

- 📁assets

  - 이미지 및 아이콘을 모아두는 폴더입니다.

- 📁components

  - 화면을 구성하는데에 있어 필요한 컴포넌트들을 모아둔 폴더입니다.
  - 페이지 전반적으로 사용될 수 있는 컴포넌트는 common 폴더에 모아뒀습니다.
  - 그 외에 common급은 아니지만 페이지 전반에 사용될 수 있는 컴포넌트들이 존재합니다.

- 📁hooks

  - Custom hooks를 모아둔 폴더입니다.

- 📁layouts

  - 페이지 전체에 적용할 레이아웃을 넣은 폴더입니다.

- 📁pages

  - 라우터의 주소를 기준으로 각각의 페이지를 모아둔 폴더입니다.

- 📁services

  - 프로젝트에서 사용되는 서비스들을 모아둔 폴더입니다.
  - Firebase 설정, 로그인 서비스, Database 서비스 등이 있습니다.

- 📁states

  - Recoil과 관련된 파일들을 모아둔 폴더입니다.

- 📁styles

  - 전역 스타일링, 변수, mixins 등 프로젝트에서 사용되는 스타일링 관련 파일들을 모아둔 폴더입니다.

- 📁types

  - 전역으로 사용되는 타입들을 모아둔 폴더입니다.

- 📁utils

  - 앱 전반적으로 사용되는 변수, 함수, 그리고 데이터 등을 담아둔 폴더입니다.

## 3. 구현 방향성

- Airbnb 설정을 기반으로 한 기본적인 ESLint 설정을 하고 rules를 추가하여 린터를 엄격하게 설정하였습니다.
- 필요한 라이브러리가 있다면 최대한 활용하되 작동 방식을 이해 하지 못한 상태로 무작정 사용하는 것은 지양하였습니다.
- 반응형으로 구현하여 어떤 화면에서든 사용 가능하도록 구현하였습니다.
- 최대한 심플한 디자인을 추구하였습니다.
- Firestore에 쓰고 읽을 때 쿼리 횟수가 많아지면 데이터베이스에 무리가 갈 뿐만 아니라 사이트 또한 느려질 수 있기 때문에 이를 최소화 하기 위해 고민하였습니다.

## 4. 구현 사항

초기 계획에는 두 영웅 중 한 명을 선택하여 통계를 내는 기능과 더불어, Firebase를 활용하여 사람들이 선택하는 영웅의 수 랭킹에 누적되어 나타나도록 구현하려 했었습니다. 또한 한번 등장했던 영웅은 다시 등장하지 않도록 함으로써 개인 별로 중복이 일어나지 않도록 구현하고, 영웅 별 상세 정보도 구현하려 했으나 시간이 부족했던 관계로 구현이 미흡한 상태입니다.

### Choice

무작위로 영웅이 등장하면 한 명을 선택하는 화면입니다. 영웅의 이미지, 이름, 그리고 능력치가 카드로 나타나며 둘 중 마음에 드는 영웅을 선택하면 됩니다. 이 곳에서 선택하는 영웅들은 Firestore에 저장 되어 Rankings에서 몇 번 선택됐는지 확인할 수 있습니다. React Query의 cache와 stale을 활용하여 한번 fetch 되었던 영웅은 다시 fetch를 할 필요가 없도록 구현하였습니다. 또한 fetch가 이루어지는 동안 로딩 스피너(Spinner)가 출력됩니다.

### Rankings

Choice에서 영웅들이 몇 번이 선택되었는 지 순위를 확인할 수 있는 화면입니다. 사람들이 가장 많이 선택한 영웅이 무엇인지 Firestore로부터 가져와 순서대로 출력합니다. 마찬가지로 React Query의 cache와 stale이 활용되어 choice에서 한 번이라도 fetch가 된 적이 있는 영욷들은 다시 fetch가 이루어지지 않습니다.

### Login

Google과 GitHub 계정으로 로그인을 할 수 있습니다. Firebase Authentication을 활용한 로그인이므로 아이디, 비밀번호, 개인정보 등은 수집되지 않습니다.

## 5. 구현 상세 설명

구현 과정에서 가장 중요한 부분은 API 통신을 얼마나 효율적으로 할 수 있는지였습니다. 받아올 수 있는 영웅의 수가 700개가 넘어가기 때문에 불필요한 통신은 최소화 해야 했으며 700개 이상의 영웅이 무작위로 나올 수 있도록 구현하는 것이 필요했습니다.

### utils/getHero.ts

React Query에서 사용되는 fetcher 함수입니다. heroId를 인자로 받아 특정 혹은 무작위 영웅의 정보를 받아오는 용도로 사용됩니다.

### constants/randomId

무작위 영웅의 아이디를 생성하기 위해 1부터 731 사이의 무작위 숫자를 가져오는 함수입니다. 단, 영웅 정보가 존재하지 않는 번호가 있기 때문에 `utils/data/HeroID.js`에 존재하는 번호만 입력하여 필터링하였습니다.

### 반응형 구현

카드 내에서 영웅의 이미지 및 텍스트의 가독성이 화면 크기와 무관하게 좋아야 하기 떄문에 반응형을 구현하였습니다. 1024px 미만에선 카드 내 요소들이 수평 정렬이 되고 선택 화면은 수직 정렬이되며, 1024px 이상에선 카드 내 요소들이 수직 정렬이 되고 선택 화면은 수평 정렬이 됩니다. 또한 Rankings의 경우 'display:grid'를 활용하여 화면이 1024px 미만일 때는 한 줄씩, 1024px 이상일 때는 3개의 열로 표현됩니다.

## 6. 어려웠던 점, 배운 점, 그리고 느낀 점

- 프로젝트를 진행하던 중 사용하던 API가 삭제되어 난관에 봉착했었습니다. 오랜 시간 GitHub과 구글을 탐색한 결과 비슷한 API를 찾아내어 다행히 프로젝트를 이어갈 수 있었습니다. 
- Firebase를 오랜만에 사용하다 보니 까먹은 부분들이 있어 구현에 시간이 걸렸습니다. 다시 공식 문서를 읽어 보고 이전에 했던 프로젝트들을 들여다 보며 하나씩 구현해가면서 감각을 되살릴 수 있었습니다.
- 익숙하지 않은 기술 스택들을 모두 사용해보며 숙련도를 올릴 수 있어 도움이 많이 됐습니다.
- 사용자 입장에서 예상하는 UI의 위치와 작동을 고려하며 디자인을 구성함으로써 UI & UX 측면의 공부를 할 수 있었습니다.
